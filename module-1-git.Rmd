# Introduction to Git and GitHub

This module consists of introductory text, four videos, and thre exercises to
get you started using Git and GitHub.


## What are Git and GitHub and how might they be useful?

As a biology graduate student or a professional biologist in a university or
government setting, there are several reasons you might want to use Git and
GitHub. We'll discuss these shortly, but first give two definitions:

`r colorize("GitHub")` refers to the website [github.com](http://github.com){target="_blank"}
where millions of people and companies 'build, ship, and maintain their
software'. This is organised by users having a unique username. For a particular
project, a user creates a `r colorize("repository")`, which is basically a collection of code
needed for that project. Repositories can be public (anyone can see them) or
private (only accessible to users specified by the original owner). Hosting code
in a public GitHub repository allows users to share their code with the world
and collaborate with anyone. The term `r colorize("repository")` is generally used
interchangeably to mean both the collection of code (which includes some files
that Git uses) and the
GitHub website that hosts the collection of code.

`r colorize("Git")` is software that keeps track of the latest versions of your
files on your local computer. Your files can include computer code, data, write-ups of your
work, etc. Git allows you to interact with GitHub to fetch code that others have
changed, and to push your own changes so that others can retrieve
them. Crucially, it allows you to merge each other's changes and easily keep
track of who has done what. It is called a 'version control system', which means
that you can go back to all earlier versions (instances) of your repository --
this is occasionally very useful.

The three main ways that you may want to use Git and GitHub are (starting with
the simplest):

 1. You want do download someone else's code from their GitHub repository.
 2. You want to share your own code on GitHub with others. This will automatically
    include the version control aspect  mentioned above.
 3. You want to collaborate with colleagues on a project.

We will work through these in order, giving more motivation for each as we go
along.

## You just want do download someone else's code from their GitHub repository

Each GitHub repository can be viewed on GitHub. We will first take a five-minute
video tour of a GitHub repository, showing:

 - the layout of the GitHub website of a repository
 - the most useful parts to know about
 - how to download the code if you just want to get it and don't intend to
   collaborate (click the green 'Code' button and 'Download Zip'); useful to get
   the code to a supervisor, say.
 - just download one file by clicking on Raw and then save-as.

So grab some popcorn and watch Video 1:

[![](https://img.youtube.com/vi/IgwSOxANT08/hqdefault.jpg)](https://www.youtube.com/watch?v=IgwSOxANT08){target="_blank"}

To access a private repository, and for the rest of this module, you will need to set
up a GitHub account:

* Sign up for GitHub at [github.com](http://github.com){target="_blank"}
* If possible, choose a user name that will make sense to colleagues,
  e.g. __andrew-edwards__ or __cgrandin__, not __pink-unicorn__ (such a name may
  make sense to your current colleagues, but you may want something more
  professional so that future colleagues know who you are)
* Desirable: attach a photo (headshot) to your profile. This makes it easy for collaborators to identify you.

For accessing a private repository, your colleague has to invite you from their
GitHub repository page (they would do Settings-Manage access). You will get an
email invitation, and once accepted you will have access to the repository when
you are logged into GitHub.


## Motivation for learning more

The above example is pretty basic. Motivation to learn more comes
from various reasons:

* Scientists (including students) are working far more collaboratively than in the past
* This involves both sharing code and writing up results
* There is a push towards open science -- including your code as part of a scientific paper
* We have called this a [TTT approach](https://waves-vagues.dfo-mpo.gc.ca/Library/40750152.pdf){target="_blank"}:
  + Transparent -- a clear and open way to show data, code, and results, enabling reproducibility
  + Traceable -- a clear link from database queries and code to final results (numbers, tables, and graphs in a document)
  + Transferable -- it should be feasible for another person to reproduce work and build upon it with a minimal learning curve

Using Git and GitHub in your workflow greatly enables this, both when working alone and in a team.
We use them extensively:

* to collaborate on writing code and producing documents (such as this entire
  set of modules!).
* to easily share code and R packages publically for scientific papers, and
  update them as necessary.
* when working alone to retain a methodical workflow.

### Example application -- Pacific Hake stock assessment

Under a formal Agreement between the Canadian and US governments, a team of four
of us (two from each country) conduct an
annual stock assessment for Pacific Hake (_Merluccius productus_) off the west
coast of Canada and the US. The assessment is used to manage the stock, which is of important
ecological and economic value ($100 million export value in Canada).

```{r, echo = FALSE, fig.alt = "Artist rendition of a Pacific Hake.", width="50%", fig.align = "center"}
knitr::include_graphics("hake-picture.png")
```

We fit complex population models to data to make projections about future
health of the stock under different levels of catch. There is an extremely short
turnaround (four to five weeks) between getting the final data, doing the analyses
(model runs can take many hours of computer time), resolving new problems, and submitting the
assessment document, which is typically >200 pages and contains numerous figures
and tables [(2021 assessment available
here)](https://media.fisheries.noaa.gov/2021-03/hake-assessment-post-srg-final_20210303.pdf?null){target="_blank"}.

Prior to 2016, the document was assembled in Word, requiring lots of editing
and amaglamating of files, often late at night. Now we share our code via
GitHub, automate a lot of the document production using knitr (similar to
Rmarkdown which is covered in Module 2).

So with four people constantly working on the same large document, we need to
ensure we are keeping up-to-date with each other, can all produce the latest
version, and have `r colorize("identical")` folder structures on each other's
computers. The alternative of emailing files back and forth is:

* very inefficient,
* prone to errors,
* just painful.

### Examples of what we can avoid

Here are some real-world examples from *not* using GitHub, showing what we
can *avoid* when using GitHub.

1. Using GitHub it is easy to see what text/code collaborators have changed, avoiding
things like the following example of Track Changes in Word, for which it hard to see where to get started:

```{r, echo = FALSE, fig.alt = "Example of Track Changes smorgasbord in Word.", out.width="80%", fig.align = "center"}
knitr::include_graphics("interim.png")
```

2. Often we may want to keep old versions of files (and email them back and forth), but
without GitHub we can end up with a veritable gong show, with multiple saved
versions of the same file:

```{r, echo = FALSE, fig.alt = "Example of having multiple saved versions of a file.", out.width="80%", fig.align = "center"}
knitr::include_graphics("EAversions.png")
```

3. We can avoid having to manually co-ordinate having only one person working on the latest
version of a document. So we don't get things like this example, which tells me
I shouldn't really do anything now and should wait until others are done merging edits:

```{r, echo = FALSE, fig.alt = "Example of having to wait for colleagues to merge edits.", out.width="90%", fig.align = "center"}
knitr::include_graphics("proposalEmail.png")
```

4. We can avoid having multiple versions of a file that then have to be carefully merged:

```{r, echo = FALSE, fig.alt = "Example of having to manually manage multiple version of the same document.", out.width="90%", fig.align = "center"}
knitr::include_graphics("dogsBreakfast.png")
```

While GoogleDocs, for example, is fine for collaborating on a short document, it
isn't suitable for sharing code that needs to be run on your local computer (or
complex code containing files that refer to each other),  or complex documents
that are somewhat automatically updated.

### Example of advantages that arise from using GitHub

1. Say you've off on a two-week hike while your collaborators
have been diligently working away and they have edited 15 new files of code in
five folders, added four data sets, and created five new pages of text towards
a manuscript. With GitHub you can easily
catch up with them (get all their changes onto your computer) with a few
simple commands. You don't even have to pester them to ask what they've done,
as you can check it yourself.

   So rather than this conversation:

   * You: "Hey, I'm back from my awesome trip and saw some bears. What have you
     been doing with the project?"

   * Likely reply: "Glad you had fun. I'm busy on something else right now. Er,
     where were we at when you left?"

   You can have this one:

   * You: "Hey, I'm back from my awesome trip and saw some bears. I went through your
     commits on GitHub and everything looks great. Shall I get on with those
     questions you asked in the GitHub Issues regarding methods?"

   * Likely reply: "Glad you had fun, looking forward to hearing about it. I'm busy
     on something else right now so, yes, resolving those Issues will be great,
     thanks."

   And the project keeps moving in an efficient way. We'll cover GitHub Issues later.


2. By having code shared publicly, it is easy to answer questions, such as
   this one I once received:

```{r, echo = FALSE, fig.alt = "Question someone once had about some code.", out.width="90%", fig.align = "center"}
knitr::include_graphics("MEEcodeQuest.png")
```

   Rather than go searching on my laptop for the code that I hadn't looked at
   for six months, I could immediately open the file (on GitHub) by clicking on the
   link the questioner sent. I could answer very
   quickly, with a simple link to the file I am referring to (there is no ambiguity):

```{r, echo = FALSE, fig.alt = "Reply showing link to code on GitHub.", out.width="70%", fig.align = "center"}
knitr::include_graphics("MEEcodeAnswer.png")
```


3. You can even work out who last edited a particular line of code/text (GitHub
   amusingly calls it 'Blame'). Just open a file on GitHub and click Blame:

```{r, echo = FALSE, fig.alt = "Example of GitHub showing who wrote each last line of a file.", width="130%", fig.align = "center"}
knitr::include_graphics("blame.png")
```

   Though you'll often find that it was you all along:

```{r, echo = FALSE, fig.alt = "Very amusing cartoon based on the storyline in every Scooby Doo episode. ", width="100%", fig.align = "center"}
knitr::include_graphics("scooby-blame.png")
```


4. You can properly keep track of 'Issues' on GitHub (discussed later) to be
   thought about or  fixed, rather than having things in emails that get forgotten:

```{r, echo = FALSE, fig.alt = "Example of GitHub Issues.", width="100%", fig.align = "center"}
knitr::include_graphics("hakeIssues21.png")
```

5. **Important:** You still have all your work locally on your computer. So if
  your internet access goes down or GitHub is unavailable (which of course will only happen
  when you have a deadline) you can still carry on with your work.


### Why this course?

Delving into the Git and GitHub world online it can feel like you need a
computer science degree to get started. This may not be surprising as Git
was written by the guy who wrote the operating system Linux, to help people
collaborate on writing the operating system Linux. But it means that, for
example, the second paragraph of the Wikipedia Git page says:

"As with most other distributed version control systems, and unlike most
client–server systems, every Git directory on every computer is a full-fledged
repository with complete history and full version-tracking abilities,
independent of network access or a central server."

Say what??? That is fairly incomprehensible to those without strong computer science
backgrounds. The aim of this module is to introduce biologists to the world of
Git and GitHub, while avoiding a lot of the technical details. However, once you
have mastered the basics then it should be easier to delve deeper.

Our target audience is:

* graduate level biology students
* biology faculty
* government scientists
* scientists in non-governmental organisations
* in fact anyone wanting to learn these tools

This work is extended from lectures and exercises developed by Chris Grandin and
myself as part of a
[Fisheries and Oceans Canada workshop](https://github.com/pbs-assess/TTTworkshop){target="_blank"}. (Luckily Chris
_does_ have a computer science degree, and so was able to get some of us going
with Git and GitHub several years ago). These tools are now widely used within
our organisation.

### Does it matter which computer language my code is in?

For sharing code, it doesn't matter what language your code is in (R, Matlab, Python, C,
...), as we will just be sharing text files. There is a learning curve, but once
you get going you only really need a few main commands. Unfortunately the hardest bit is
actually getting everything set up....

## Getting set up for the first time

Before you start using Git you need to set up your computer to use it, and
install a few other programs that are useful.

This is a `r colorize("one-time setup")`
and, although it can sometimes be tricky, once it is done you
will be able to easily create new projects or join others in collaboration.

We have tested the installations as much as feasible. If you have an issue then
search the internet, as it may be due to some configuration on your particular
computer, and installation approaches do get updated.

This module is for any operating system: Windows, MacOS, Linux or Unix.

### What you will end up having installed
These are programs/things you will install. Obviously skip any that you already have working.

* A GitHub account (see earlier for instructions)
* A text editor that isn't Notepad
* Git on your computer

Optional:

* Diffmerge or something similar for comparing changes to files (not completely necessary)
* Markdown Pad 2 or Chrome extension or something similar for viewing Markdown files (not completely necessary)


### Text Editor
You must have a text editor that is aware of outside changes in a file. This is necessary because if you have a file open in the editor and you download an updated version of the file, you want the editor to ask you if you want to use the updated version.

We know that __Emacs__, __Xemacs__ and maybe __Vim__ are okay, as is __RStudio__
for using R (and other) files.

__Notepad__ is not okay. But you can download and install __Notepad++__ which is fine:

https://notepad-plus-plus.org

### Install the Git application on your machine
See https://git-scm.com/downloads for downloading instructions for Windows, MAC and Linux/Unix

It seems best to accept the default options, except:

* default editor: as it says, you probably want to switch from Vim (unless you
use Vim) as the default editor. This option seems to be for the editor that will be
used if Git needs to open a text window for you to edit (which will be rare),
not for editing your own files. Notepad seems fine here if you like.

* 'Adjusting the name of the initial branch in new repositories' - click
 'Override the default branch name for new repositories' and leave it as
 `main`.

### Git shell, GUIs and RStudio
For this course we will use a simple Git shell to type commands (rather than a point-and-click Graphical User Interface). This is for several reasons:

1. Commands are the same across operating systems.
2. It is easier to demonstrate (and remember) a few simple commands, rather than follow a cursor moving across a screen.
3. Learning the text commands will give you a good understanding of how Git and GitHub work.
4. It is easier to Google for help when you get stuck or want to learn about more advanced options.
5. Commands are quick, and you can usually the up arrow (or ctrl-up-arrow) to
   retrieve recent commands, or auto-complete commands using `<TAB>`.

There are many Graphical User Interfaces that are available, as described at https://git-scm.com/downloads/guis.

Many (but not all) biologists use R in RStudio for their analyses. There is Git
functionality built into RStudio that we discuss briefly at the very end of
this module.

I use [magit](https://magit.vc/){target="_blank"} which works in the text editor Emacs (which for years I have used
for pretty much everything, such as editing files, running R, Matlab, etc.). But
I would not have been able to learn magit without first knowing the Git commands
from using the shell.

For now we will stick with the Git shell for the aforementioned reasons. It will
also give you a better understanding of Git and GitHub, and emphasise that you
can use Git for any files, not just R code.

### Powershell and posh-git

Download a Powershell (a shell window in which you can type commands, presumably
the 'power' part means it's more powerful than a basic version) and then
posh-git (which adds some extra features). Do this by following the instructions at
https://github.com/dahlbyk/posh-git .

Note that that is a GitHub site -- it is storing the code for `posh-git' (so
anyone can see the code), but when you scroll down you see instructions (like in
the repository example in Video 1).

Do the 'Installation' and 'Using posh-git' sections. If you don't understand
some options (I don't!) just pick the simplest, usually the first.

### Create a directory to keep all your Git-tracked work

It is handy, but not essential, to keep directories that you are tracking
with Git and GitHub all under a single directory; it's a helpful way of
reminding you that you are tracking such directories with Git.

You can use something like `C:\github` (Windows) or `~/github` (Mac) or whatever
you like, but make sure there are no spaces or special characters anywhere in
the full path.

So create such a directory. You will navigate to it later when using Git. TODO

### Install Diffmerge (optional)

A differing tool can be used to examine differences between different versions of
files. There are
many programs that can be used but for consistency we will use Diffmerge.

It is nice to have but not essential if you have trouble installing it.

Install Diffmerge: https://sourcegear.com/diffmerge/downloads.php

### Save our template _.gitconfig_ file

* Git uses a configuration file (called _.gitconfig_) for your account info, name to use when
  committing, aliases (shortcuts) for commands, and other things.
* We are supplying a template _.gitconfig_ file that you will then edit.
* For Windows, you will save it as
  `C:\Users\YOUR-COMPUTER-USER-NAME\.gitconfig`, where YOUR-COMPUTER-USER-NAME
  is your username on your computer.
* For MAC and Linux (we think), you will save it as `~/.gitconfig`.
* If there is already such a file there maybe save a copy of it under a
  different name so you don't completely overwrite it in the next step.
* The template file is on GitHub
  [here](https://raw.githubusercontent.com/quantitative-biology/module-1-git/main/misc/.gitconfig){target="_blank"}. Do
  `Save-As` (right click or from a menu) and save the file as the filename mentioned above.
* Just a reminder for your understanding: that file on GitHub is
  shown in the normal way on the Github repository for this module:
  https://github.com/quantitative-biology/module-1-git/blob/main/misc/.gitconfig
  and the link we gave you is from clicking `Raw', which just gives you the raw
  code for the file -- this works for any file on GitHub, as mentioned in Video 1.

### Edit the _.gitconfig_ file

* Use your text editor to open your saved _.gitconfig_ file. Given it has a non-standard
  extension (i.e. it is not something like *file.txt*) you may have to specify
  to open it with your editor.
* Change the [user] name and email settings to reflect your information.
* Change the [difftool] and [diffmerge] directories so they point to the
  location where you have DiffMerge (if it installed okay).
  * For Windows the location should be: `C:\Program Files\SourceGear\Common\DiffMerge\sgdm.exe`
  * For MAC the location should be: `/usr/local/bin/diffmerge`
* If you did not install Diffmerge then delete the nine lines from `[diff]` down
  to `   trustExitCode = true` in your _.gitconfig_ file.

### GitHub authorisation

You will use Git to communicate back and forth with your repository on the
GitHub website. You don't want to have to enter a password every time. This
is currently done by creating something called a Personal Access Token (PAT).

If using R then do:
```
install.packages("usethis")    # Unless you already have the usethis pacakge
install.packages("gitcreds")   # Unless you already have the gitcreds pacakge
usethis::create_github_token() # This opens up GitHub in your browser to set up
                               #  a PAT token. Copy and paste the next line into
							   #  R and then complete the setup on GitHub
							   #  (stick with defaults), copying the resulting
							   #  PAT token to your clipboard.
gitcreds::gitcreds_set()       # Paste the PAT token from the clipboard as
							   #  requested.
```

This seems to be the simplest method. If you don't use R then either

1. Install R [from here](https://www.r-project.org/) and just copy the above
lines into an R window. It obviously may seem overkill to install R just to set
up something else, but the PAT stuff is fairly new, and the R route is fairly
straightforward.

2. Else, try [these
instructions](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token). They
mention that you may be asked for your PAT the first time you use
Git (with the `git clone` command you will see soon), and that your PAT may get
cached (meaning you don't have to keep entering it every time you interact with
GitHub). If you repeatedly get asked for your PAT then see the instructions at
the bottom of that page regarding caching your credentials.

### Navigating in a shell

You need to know how to change directories in the Git shell. This is like
clicking on folders or going back in File Explorer (Windows) or Finder
(Mac). Bascially you use

`cd <dir.name>`

to change directory (move into that directory),

`cd ..`

to go back up again, and

`dir` (on Windows) or

`ls` (on Mac)

to list the contents (either command works for Linux). These are shown in the
following screenshot, for which I opened up my Git
shell in Windows and did the above commands,
moving into the `test` directory, seeing what's there, and then moving back up:

```{r, echo = FALSE, fig.alt = "Screenshot of basic shell commands.", width="100%", fig.align = "center"}
knitr::include_graphics("shell-commands.png")
```

You will create such a `test` directory during Video 2.

### One-time authentication

The first time you get set up or start using Git, there might be some one-time
authentication to connect to your GitHub account. For
example, in Windows you might be asked to type

`git config --global credential.helper wincred`

in the Git shell. So just follow any instructions if they come up.

### MAC only: make your output pretty
On the MAC, navigate to the `~/github` directory in a shell and run the following command:

`git config --global color.ui.auto`

This will make your git output colored in a similar way to the Windows powershell version.


### Something to view Markdown files (optional)

Each project has an associated *README.md* file that appears on its GitHub
homepage. The extension `.md` stands for Markdown and is just an ASCii text file
that contains simple formatting (such as bold or italics). You can edit the file
in any text editor. There are two options we have used to view the rendered
versions of markdown files (rendered means it utilises the formatting you have
coded). Choose one:

* The Markdown Pad 2 editor/viewer which is easy to use: http://markdownpad.com. Just get the free version.
* The Chrome extension for markdown viewing: https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk?hl=en.

Here is an intuitive short introduction to Markdown, which is worth looking at
once you start writing more in your *README.md* files:
https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet.

With one of the above two options installed when you click on a *README.md* file
you can edit the file and also see the rendered (formatted) version. I find that
Markdown Pad 2 doesn't show (render) the *README.md* file exactly the same way as it
appears on the GitHub website, with the GitHub version being better.

### Bonus keyboard shortcut (optional)

In the upcoming Video 2, I may occasionally type `g` instead of `git` as I have that shortcut
set up. To enable this shortcut for yourself (this is not essential), create a
file (on Windows at least) called *g.bat*
somewhere on your PATH, and have it contain just the line `git %*`.
