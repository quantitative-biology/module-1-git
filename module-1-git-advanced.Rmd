## Beyond the basics of Git and GitHub -- getting more advanced

This section gives slightly more advanced background that should further improve
your understanding (including why Git is useful even when not collaborating or
sharing your code).
If you're doing this module for the first time maybe read this section now so
that you know what is here, but don't worry
about understanding it all until you have become more familiar with using Git and GitHub.

### So I've made some changes but don't really want to keep them -- git stash

If you've changed some code but _have not committed it_, and then maybe got in a
mess and just want to go back to your last commit, you can _stash_ your changes
```
git stash
```
and to include a message (for your future self):
```
git stash save "Message"
```

This stashes them away such that they can be retrieved later if necessary.
This is handy. You may _think_ you don't want to keep those changes, but
sometimes you may later wish you had kept them somehwere.
Note this is only for files that Git is tracking (i.e. files that have been added
at some point).

To retrieve the last stash, you 'pop' them back into your working copy with:
`git stash pop`

You can have multiple stashes, seen by doing:
```
git stash list
```
To deal with these, and other aspects of `stash`, see [this tutorial](https://www.atlassian.com/git/tutorials/saving-changes/git-stash){target="_blank"}.

If you are really really sure that you do not want to keep your recent changes,
see the 'Undoing changes not yet committed' section near the end of this module.

### The power to go back

With Git you can revert back to any previous state of your repository.
This is `r colorize("very powerful")`, though slightly
`r colorize("scary")` at first.

Do this with your test repository, that should have some files in it from the
  earlier excercise:

* `git s` to make sure you are all up-to-date
      (`commit` and/or `push` if necessary).
* In File Explorer (or whatever you use) look at your repository, you should see
    all your files, including the `new-stuff\` directory.
* Look at the commit tab on GitHub for your test repo and click on the clipboard
      icon to copy the HASH number thingy to the clipboard .
* In Git shell: `git checkout HASH` (where `HASH` is the pasted HASH, or `git co
  HASH` using our Alias)
* Look at File Explorer again -- your `new-stuff` directory should
      have ... disappeared!!
* (If it hasn't disappeared then open it -- the test files, i.e. `test1.r`,
      `test2.r`, etc. should be gone, but your text editor may
      have saved backup versions; manually delete them plus the
      `new-stuff/` directory.)
* You are now back to the very first version of your repo!

Powerful and scary.

Now, to get your files back to the most recent version you had committed:

* `git checkout main`   (it used to be `git checkout master`, the names have recently changed).

That's it! Check that your files are back. All this means that you can
`r colorize("revert to any previous commit in your repository")`.

This is very reassuring. For example you have some complex code that you realise
  is now a complete mess and you want to go back to yesterday's version of everything.

In practice you rarely actually do this, but it's very comforting to know
  that you can.

Consequently, your workflow is less cluttered and more tractable than having
  to save multiple versions of the same files with dates in the filename, such
  as this nightmare:

```{r, echo = FALSE, fig.alt = "Example showing multiple saved versions of the same file, to show what you can avoid by using Git.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/EAversions.png",error = FALSE)
```

**Retrieving older work in practice**

I think there are fancy ways that Git can replace a current file with a version
from an earlier commit. But, in practice (especially since you rarely want to do
this) it is a bit safer to do the following:

* Say you are up-to-date (`git s` says all is good), but your program
  `my_code.R` just isn't working and you want to go back to the version you had
  yesterday at commit number `abc123`.
* `git co abc123` (or `git checkout abc123`) to checkout the earlier commit,
  which includes the old version of `my_code.R` that you want get.
* Copy `my_code.R` to a new file `my_code_old.R`. In the shell you can just do
  this with `cp my_code.R my_code_old.R`.
* Do NOT edit `my_code.R` or make any changes, as you may end up with a scary
  `DETACHED HEAD` warning.
* `git co main` to checkout the latest version again.
* Since you have NOT done `git add my_code_old.R`, Git is not tracking
  `my_code_old.R` and so it is just sitting in your folder as normal.
* Now you can manually copy what you want from `my_code_old.R` into `my_code.R`
  to fix your problem. It could be the full file, or just some part of it.
* Then commit as normal.
* At some point you can delete `my_code_old.R` so it is not hanging around, but
  you don't have to. (Though maybe make a note in it as to which commit it was
  from, in case you do need it again).

### So how does Git do all this?

By now you're probably wondering how Git keeps track of everything.
Git does not keep versions of code, it keeps _commits_. The commits
are kept track of using a HASH key which is a generated 40-digit key in
hexadecimal (base 16). The hashes are
what you see on GitHub and in various places when you use Git shell.

By stitching all the commits back together again, Git can recreate all your code.

There is a hidden `.git/` directory in each repository.
Look at the `.git/objects/` subdirectory. Each subdirectory name is the
first two digits of a HASH. The rest of the digits of the HASH are the filenames in the
subdirectory.

You can basically think of the hashes as representing `commits` (apparently they can also
be `blobs` and `trees`, whatever they might be).
I think of the files in the subdirectories containing the `r colorize("differences")` between each commit.

Because of these structures, Git can go back and `r colorize("rebuild")` any or
      all files at any `commit`, and even have different directory
      structures at each commit.

Since Git is keeping track of differences between files, this all works best for
      plain ASCii (text) files, such as `.R`, `.txt`, `.Rmd`, etc.

Git does work for binary files, such as `.xls`, `.docx`, `.RData`, but since
      changes to the files are not easily saved (Git essentially has to resave
      the whole file at each commit), this is not very efficient and may make
      your repository large. Such files will be fully resaved every time they
      are changed. Think of a binary file as something that you cannot open in a
      text editor and read (it does not contain simple ASCii letters and numbers).

Exceptions: often you may have an image or photo or other type file that you need to share for a
      document, but it isn't going to keep changing. So that's fine to commit.

An example of why you should not commit binary files:

* A collaborator was running some R code (and correctly committed the `.R` files
  so that I could run it), but also committed the results, which included
  `.pdf`, `.png` and `.RData` files, which can get quite large.
* But, these latter files got updated every time the code was run. So changing
  one line of the `.R` code (which Git deals with very efficiently), and running
  that code and committing, resulted in the new `.pdf` etc. files being fully
  saved (since Git cannot just save the difference from the last commit because
  they are binary files). Even
  if, say, one point changes on a figure in a graph in a `.pdf` file, Git has to
  save the whole new version.
* This ended up with `.git/objects/pack` (whatever that might be!) being 2.8Gb.
* I needed space quickly on my computer so just deleted four files in
  `.git/objects/pack`, which freed up 1.6Gb.
* Note that I still had the actual final versions of files (as you would
     if not using Git), but just not the full repository history.
* However, when I tried to later do some work and then `commit` I got lots of
'fatal' errors with scary messages like `bad object HEAD` and the awesomely titled `You are
on a branch yet to be born`:

```{r, echo = FALSE, fig.alt = "Example of why you shouldn't mess with the .git directory, as you get confusing error messages and have to start again.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/notGood.png",error = FALSE)
```

I just had to start again from scratch (`clone` again I think). Take-home message:

**Don't mess with the .git directory!!**

### Git terminology

At some point you will likely need to search online for some help (often
questions are posted and answered on the excellent 'stackoverflow' website).
A bit more understanding of terminology will help you.

Remember that Git keeps _commits_.
Several of these commits have pointers to them that have special names:

* **HEAD** points to the commit you are currently on in the Git shell.
* **main** or **master** is the default branch when you set up a repository on
    GitHub (it is usually **main** now because of recent changes on GitHub).

### Branching

So far we have only worked on the **main** branch. Sometimes you want to create
a new branch that branches off from the **main** branch. It's bit like a tree
branching, except that at some point you want your new branch to be merged back
into **main**.

For example, you may want to try adding some new code to your project, but don't
want to break what is already there. You may do this even if working alone, but
it's especially useful if you are collaborating, or if, say, you have an R
packages hosted on GitHub that anyone may be downloading -- you don't want to
annoy them by pushing experimental code that doesn't work.

So you would create a new branch, work on that new branch (i.e. commit
changes to the new branch), and when you are happy with your new changes you can
easily merge it all back into **main**.

**Working on a new branch**

When creating a new branch, your starting point is identical to the branch you
were when you created the new one.

In the Git shell navigate into your test repository:

  `cd test`

Depending on your set up, you should see `main` indicated somewhere (if not do
  `git s` and it should say `On branch main`.

Make sure you are up-to-date and have committed all changes (`git s`, and
  `commit` if necessary).

Create a new branch called _temp_, this will be based off the latest commit of the  _main_
  branch you are currently on:

  `git checkout -b temp`

(We have an alias for that: `  `git cb temp`).

You will be automatically placed in the new branch called _temp_, and commits
  you make will now occur in that branch only.

Make and `commit` some changes (e.g. add a new file) -- these will now be on
  your _temp_ branch.

You can push to GitHub. The first time you try `git p`, the Git shell will
  tell you that you need to type the following so that future pushes go to the
  new branch:

`git --set-upstream origin BRANCH-NAME`

Check the GitHub webpage to see that your branch was pushed. You repository
  page (that will still be looking at your _main_ branch) may tell you that
  there is a _temp_ branch with more recent commits than _main_. If not then if
  you click on the _main_ drop-down menu:

```{r, echo = FALSE, fig.alt = "Example of clicking on main drop-down menu on GitHub to view other branches.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/main-branch.png",error = FALSE)
```

it should give you the option to look at your new _temp_ branch. (The '1 branch'
in the above image should also say '2 branches').

You can now view your new file in your new _temp_ branch on GitHub.

A graphical way to see and understand branching is to click on
  Insights--Network to see the Network graph.

The Network Graph is a useful visualization tool, where each commit is shown as
a point on the graph (the numbers along the top are the dates). You can hover
your mouse over a commit to see who committed it and the commit message. You can
click to see full details of the commit. The Network Graph is particularly
useful if you or others are working on multiple branches, or to check details
about merges.

Okay, back in your Git shell you can easily switch back to your original _main_
branch:

`git checkout main` (or the alias `git co main`).

You will see that the file you just added is gone, because it
`r colorize ("only exists in the _temp_ branch")`
at this moment.

Imagine that in your _temp_ branch you did several commits to create a new
function in your code, or have added some new text to a report. Now you are
happy with what you've done you want to merge it back into the _main_ branch.

To view all local branches:

`git branch`

There is an asterisk next to the branch you are currently in.

To switch to another branch (_main_ in our case):

`git checkout main`

To combine the changes from the _temp_ branch:

`git rebase temp`

or

`git merge temp`

Now the file you created in the _temp_ branch now appears in the _main_
branch. All commits done in the _temp_ branch will now be in the _main_ branch
as well.

If there was a merge conflict, you must fix it at this point (see earleir).

Once you've merged your _temp_ branch into _main_, you don't really need _temp_
any more and so it is good protocol to delete to keep things tidy:

`git branch -d temp`

If you have unmerged changes in a branch, you will not be allowed to delete it,
but Git shell will tell you the command to forcibly delete it:

`git branch -D temp`

Warning -- you won't be able to get any of those changes back once you do this.

To remove a branch entirely from GitHub:

`git p origin --delete BRANCH-NAME`

### Pull requests

You often hear about 'Pull requests', but in my workflow I've rarely used
them. A pull request is when a
contributor asks a maintainer of a Git repository to review code the contributor
wants merged into the repository. It's not really used when collaborating with your
own team, but more when you have started with someone else's repository and
either made a branch or forked it, made some improvements (you hope!), and then
you request that they pull your improvements into their main repository. So
fairly advanced. For more details see [here](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests){target="_blank"}.


### Undoing stuff

If you make a commit followed by other commits, then realize you want to undo the earlier commit, you use _revert_:

`git revert HASH`

where `HASH` is the hash for the commit you want to undo. Remember that Git shell is smart enough that you only need the first five digits:

`git revert 1ef1d`

This actually creates a new commit with the automatic message

`Revert "<previous commit message>"`.

Obviously, you have to be careful with this if you're changing something that
was a few commits back, as you might mess up your code.

**Undoing changes not yet committed**

If you've made a mess in your working directory and you want to change
everything back to the way it was on the last commit:

`git reset --hard HEAD`

If you've messed up a single file and just want that one file to go back to the way it was on the last commit:

`git checkout HEAD <filename_to_restore>`

Warning -- running these commands will delete the changes you have made. Since
you have not committed any changes, they will be lost. Make sure you are certain
you don't need the changes before running these commands. If you aren't sure if
you need the changes again in the future, use `git stash` instead.

**Changing the commit message in the last commit**

If you make a commit then realize you want to change it (add more information,
fix something that will confuse your colleagues, fix something that will confuse
you tomorrow), you can change the commit message:

`git commit --amend -m "Correct message."`

This only works on the last commit.

If you already pushed the commit before realizing that the message needs modification, do this:

`git p --force`

after making the amendment to the commit message.

### Using R and GitHub within RStudio

If you use RStudio to work in R, then you
may want to use RStudio to use Git. Having already learnt the basic Git commands in a
shell should help you.

One way of using Git in RStudio is just to use the commands we have learnt
within the 'Terminal':

```{r, echo = FALSE, fig.alt = "Example screenshot of using Git in the RStudio terminal.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/Rstudio-terminal.png",error = FALSE)
```

Alternatively, the RStudio interface has buttons with words that you are now familiar with, such as
'Diff' and 'Commit':

```{r, echo = FALSE, fig.alt = "Screenshot of the Git buttons in RStudio.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/Rstudio-git.png",error = FALSE)
```
The blue arrow has options for fetching from GitHub, while the green arrow
is for pushing to GitHub.

When you commit, instead of including the message in the Git
command like we did, with `git com "<Message>"`, RStudio opens a window:

```{r, echo = FALSE, fig.alt = "Screenshot of the Git commit message window in RStudio.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/Rstudio-commit-message.png",error = FALSE)
```

As you can see, having learnt what these various Git commands mean, it may be fairly
intuitive how to proceed.

To delve further, Jenny Bryan's [Happy Git and GitHub for the
useR](https://happygitwithr.com/index.html){target="_blank"} course introduces using Git in
RStudio. It was originally developed for advanced-level statistics courses and
is aimed at intermediate to advanced R users. It does include some use of a
shell (like our module); for details on pre-requisites see
[here](https://happygitwithr.com/big-picture.html#audience-and-pre-reqs){target="_blank"}.
Having worked through our Git and GitHub module, you should
easily be able to pick up the necessary components that you need.

In this module's videos that had R code, I was using the Emacs text editor. I've
used it for years for many reasons: it automatically
highlights code in any language, is extremely versatile, has keyboard shortcuts
which you can learn once and use forever, and as such it is
fast to use when programming and
avoids lots of mouse use (which can help avoid repetitive strain
injury). I run R in Emacs with Emacs Speaks Statistics, and often use magit which is a
way of using Git in Emacs. Also, enhancements to Emacs can improve
[accessibility](https://www.emacswiki.org/emacs/CategoryAccessibility){target="_blank"} for those
that need it; for example, Emacs' customisability can [greatly improve productivity
for visually impaired programmers](https://emacsconf.org/2019/talks/08/){target="_blank"}.

Finally, one colleague use RStudio to run R, Emacs to edit R files, and
magit (in Emacs) to run Git. You will likely similarly figure out what setup works best
for you.
