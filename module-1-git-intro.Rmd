## Using Git and GitHub to share your own code

CHECK: This section also has two (TODO: may split first one up) recorded videos to
demonstrate the main concepts and ideas. We suggest watching a video and then
attempting the corresponding exercise. The notes here also give the details you
need, so you can easily refer to them after first watching the corresponding
video.

The first video is available [here](https://drive.google.com/drive/u/0/folders/1wLNNNn1e2zTKTjh8QAfTcS7L22990RRO)
and the slides from the talk are [to be added](TODO)TODO, though the notes below mostly
replicate the slides.

### Definitions

Let's recall the main definitions:

* Repository -- essentially a directory containing all your files for a
    project (plus some files that Git uses). Also used to mean the website on GitHub.
* Git -- a program that allows you to efficiently save ongoing versions of
    your files (`version control') and link with GitHub.
* GitHub -- a website that hosts your repositories so that you can easily
   share code and collaborate with colleagues.

Basically, the idea is that you work on your files in a repository on your computer, use Git on
your computer when you are happy to keep your changes, and use GitHub to easily
share the files.

In the opening video you learnt how to navigate a repository on GitHub and how
to download other people's code Here you will learn the important steps for your
own repositories:

* Creating -- create a new repository on GitHub
* Cloning -- copying it to your local computer
* Committing -- the crux of working with Git
* Collaborating -- efficiently work with colleagues
* Conflicts -- fixing conflicting changes when collaborating (happens rarely)

### Creating a new repository
* Sign into your GitHub account, click on the _Repositories_ tab, and press the _New_ button.
* Give your repository a name. Let's call it test.
* Check _Initialize_ this _repository_ with a _README_.
* Leave _Add .gitignore_ and _Add a license_ set to _None_
* Click _Create repository_.

You now have a new repository on the GitHub website. Next we will clone it onto your computer.

### Cloning your new repository

* Copy the full URL (web address) of your test repository.
* Open the Git shell and navigate to your `C:/github` directory (or whatever you called it when you created it in the setup instructions -- it's the place you are going to save all your Git repositories).
* Run the following command to _clone_ your repository:

`git clone URL`

where URL is the url of your newly created repository (paste should work).

You should now have a subdirectory called `github/test` on your computer.
In Git shell, change to that directory (with `cd test`). The command `cd` just
stands for `change directory`, to go back to where you were just do `cd ..`. You
probably want to also open the directory using your usual graphical interface (e.g. File Explorer
in Windows) to check what is happening.

So 'clone' is Git speak for copying something from GitHub onto your local
computer. This example has just one file (_README.md_). But the process is the
same for a repository with multiple files and multiple directories, and the
complate file sturcture is fully preserved.

**Windows only: Storing your credentials**

When you are using the Git shell for the very first time on Windows, issue the following command:

`git config --global credential.helper wincred`

This means that you don't have to repeatedly enter you GitHub password (just do it when you are first prompted).

### Committing

* Create a new file, _newFile.txt_, in the `github/test` directory.
* Open it, add a line of text at the start of the file and save it.
* Check the status of your (test) repository:

`git status`

* It should say that you have an 'Untracked file' called _newFile.txt_. You want
  to tell Git to start tracking it, by using:

`git add. gitignore`

* Type `git status` again.
* You should see that the file is listed as a 'new file' under 'Changes to be commited'.
* Let's now 'commit' it:

`git commit -a -m "Add newFile.txt."`

The commit message (in the quotes) should be a useful message saying what the
commit encapsulates (more on that later).

* Push the commit to GitHub:

`git push`

* Check (refresh) the GitHub webpage and see your commit and the uploaded file.

**What just happened?**

We just used three of the main Git commands:

* `git add <filename>` -- tell Git to start keeping track of changes to this file. You only need to tell Git this once.
* `git commit -a -m "Message."` -- committing your changes, which means tell Git you are happy with your edits and want to save them.
* `git push` -- this sends your commit to the GitHub website.

You always have your files stored locally on your computer (as usual), even if you don't add them or commit changes.

When you push to GitHub then your colleagues can easily fetch (retrieve) them.

**Keyboard aliases (shortcuts)**

Now,

`git commit -a -m "Message."`

is a bit much to type, so we have an alias for it:

`git com "Message."`

This is defined in the _.gitconfig_ file you installed in the `git-setup`
instructions into `C:\Users\YOUR-USER-NAME\.gitconfig` (for Windows). You can
also add your own commands to that file.

The `-a` means 'commit all changes of files that Git is tracking', and `-m` is
to include a message. Since we usually want to do both of these,
`git com "Message."` is a useful shortcut. But it is important to realise it is an alias if searching online for help.

Similarly:

`git s` -- for `git status`

`git p` -- for `git push`

`git d` -- for `git diff`

`git f` -- for `git fetch`

From now on we will mostly use the aliases. Use the full commands if the
_.gitconfig_ file didn't work for you.


**Edit _Readme.md_**

Edit the _Readme.md_ file. Add some simple comments describing the project such as: "A test repository for learning Git."

Look over the changes, commit them, and push them to your GitHub repository:

`git s`

`git d` (or `git diff`) -- this gives a simple look at the differences between
the last committed version and your current version (of all files; only one in
this case).

`git com` "Initial edit of Readme.md"

`git p` (or `git push`)

Refresh your GitHub web page and you should see your text (the _Readme.md_ file is what is shown on the main page of your repo).

### Exercise 1: create, edit and commit _simpleText.txt_

1. Create a text file _simpleText.txt_ in  your local `test` repository. Add a
   line of text at the start and save it.
2. Predict what `git s` will tell you, then type it in the Git shell to check.
3. Add the file to the repository using the git commands:

`git add simpleText.txt`

`git s` -- not necessary but useful to check you understand what is changing before you commit

`git com "Adding simpleText.txt"`

`git p`

4. Add some more test to _simpleText.txt_ then `git com "Message."` and `git p`.
5. Repeat this a few times to get the hang of it. `git com` frequently and `git
   p` occasionally (you do not have to push every commit), while intermittently doing `git s` and `git d` to understand what's changing.
6. Keep an eye on your commits by refreshing the GitHub page.

In reality when writing code/text you won't be committing quite so frequently,
as your focus will be on the writing the actual code/text.

**Adding multiple files at once**

Often you add multiple files in a new directory. When you run `git s`, you will
see a large list of _Untracked files_. They can be all added at once by simply
adding the whole directory.

### Exercise 2: multiple files

Do the following, to get the idea of creating multiple files in a folder and
committing that folder.

* Create a new directory called _new-stuff_ in your `test` repository, using your normal method
  (e.g. in File Explorer, or just `mkdir new-stuff` in the shell). Navigate to
  it in your shell (`cd new-stuff`).
* Add a few new test files to that directory called _test1.txt_, _test2.txt_,
  etc. Put some example text in one or more of them if you want.
* On the command line, check the status:

`git s`

* You will see a listing showing the _new-stuff/_ directory in _Untracked files_.
* To add all the new files in preparation for a commit, issue the command:
`git add new-stuff/`

* Check the status of the repository again with `git s`
* It will now show all files in _Changes to be committed_
* Commit the changes:

`git com "Added new-stuff directory."`

* Push the changes to GitHub:

`git p`

* Check your GitHub webpage and see your commit and that the files have been uploaded.
* That works no matter how many files are in your new-stuff directory. There
  could be a hundred and it's the same command.

**Wildcard symbol `*`**

This is useful to know (no need to do it as part of the exercise):

* To add multiple files with similar names you can use the wildcard `*` symbol.
* You just added (told Git to keep track of) the new files in your _new-stuff/_ directory.
* If you add more new files to that directory, you will have to tell Git to
  track those also. This is because they are new -- you haven't told Git about them yet.
* Say you have 10 new files called _idea1.txt_, _idea2.txt_, ..., _idea 10.txt_.
* Instead of typing

`git add new-stuff/idea1.txt`

`git add new-stuff/idea2.txt`

etc. you can just use the wildcard symbol `*` which stands for any piece of text:

`git add new-stuff/idea*.txt`

or even just

`git add new-stuff/*.txt`

or

`git add new-stuff/*.*`.

**The _.gitignore_ file**

But what if you don't want to add all the files that you create?

Each repository can have a _.gitignore_ file, in the root directory of the repository.
Such a file has names of files (such as _my-secret-notes.txt_) or wildcard names
(such as `*.pdf` or `*.doc`) that will be completely ignored by Git.

For an example, see
[https://github.com/pacific-hake/hake-assessment/blob/master/.gitignore](https://github.com/pacific-hake/hake-assessment/blob/master/.gitignore){target="_blank"},
noting that the `#` can be used for comments.


When sharing a repository with others, you want to share your _code_ (for
example, R, Python or Matlab code) and maybe data, but generally _not_ share the
output (such as figures that the code generates; more on this later). For
reproducible research your colleague (or anyone) should be able to run your code
to generate the results.

Some programs you run may make temporary files that don't need to be tracked by
Git, the names of which should also be included in your _.gitignore_.

When sharing code or collaborating you want to keep your repository as clean as
possible and not clutter it up with files that other people don't need.

So when you run `git s` and see untracked files that you don't want to be
tracked, add them (or a suitable wildcard expression) to your _.gitignore_ file
so that they are not added inadvertently.

This will also simplify your workflow (you don't need to keep being reminded
that you have untracked files).

If you are on MacOS and you find that folders have a _.DS\_Store_ file in them,
then include _.DS\_Store_ as a line in your _.gitignore_ file.

Generally, when you create a new repository you probably want to copy an
existing _.gitignore_ file over from an existing repository, as you will
generally want to ignore the same types of files.

You can also choose the _private repository_ option when creating a repository,
so that you can control who can see it. On your repository page on GitHub, go to
`Settings--Manage Access` to add collaborators.

### What to write in commit messages

You don't want to agonise over what you write in your commit messages, when
doing `git com "Message"`, but it is worthwhile making them useful. Ideally

* You want to describe *what* (and sometimes *why*) you did something.
* The *how* is not needed since that will be explained by the actual
    changes in the code. If someone wants to see how something was done, they
    can see what was changed in detail in the commit.
* The message should be informative for collaborators (including your future self).

`r colorize("Not useful:")`

`git com "Tweaked function."`

`r colorize("Useful:", "blue")`

`git com "Allow plot.biomass() to use extra colours."`

A good rule of thumb is to just complete the sentence "`r colorize("This commit will ...")`".

This is helpful for your collaborators and your future self.

You have now learnt the basics of using Git. By creating a public repository on
GitHub you can now release your code to the world!


## Using Git and GitHub to collaborate with colleagues

### Demonstration of collaborating

Now we will show how to collaborate with colleagues, which is where the
usefulness of Git will become more apparent.

There are a few different ways to collaborate using Git and GitHub. We will
focus on the following one since it is the simplest, and is what you need to
collaborate with colleagues.

Concept: there is a project where people contribute to a main repository that is
considered the 'master copy'.

* Everyone clones directly from the creator's repository.
* All collaborators push their commits to the repository (the creator has
  to add them as collaborators once on GitHub).

Since the creator has to grant permission, you won't have just anyone
contributing to (and maybe messing up your work), just your trusted collaborators.

But you have to trust your team to not mess things up (more on that later!).

Now watch this
[video](https://drive.google.com/file/d/1rqdFBnVg_zwP6SiW-KSTp6wZzAILDeeC/view?usp=sharing){target="_blank"}
in which we demonstrate the following:

* Kim creates new repo called `collaborate` (and clones it to her computer).
* Andy clones it also.
* On GitHub, Kim gives Andy 'push access' to her `collaborate` repo.
* Both do some edits (create some new simple text files).
* For Andy to get Kim's updates (and vice versa), he just uses:

  + `git fetch` (or just `git f`) -- fetches the latest version of the repository from GitHub onto your computer. Your local files have _not_ yet changed (check them), but Git has the changes stored on your computer (?!?).
  + `git rebase` -- updates your local repository (the committed files on your computer) with the changes you have just fetched, merging both people's work together.
  + `git p` -- pushes the merged changes back up to GitHub so that the other person can get them.

That is the basic workflow.

In the video you saw that we also showed an example of `git p` _not_ being allowed for Person A  because
there are recent commits on GitHub (by Person B) that Person A has not yet
merged into their local version of the repository.

Here is an example of the error message you get:

```{r, echo = FALSE, fig.alt = "Example of a lengthy error message when trying to push; essentially its just telling you to pull before trying to push.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/unable-to-pull.png",error = FALSE)
```

While a bit lengthy, the error message is useful. It forces you to get the other
person's work before you push yours. You do this by:

`git f`
`git rebase`.

So to be allowed to push, just `fetch` to get the new commits onto your computer,
and then `rebase` to combine the commits into your local version. Then you can

`git push`.

Here is a full screenshot ('g' is just a shortcut for 'git'). The green up arrow
number 8 tells me I have 8 commits to push to GitHub. The yellow arrows I think
of as just implying I need to do a rebase (before doing that I might browse
through the other person's commits on GitHub):

```{r, echo = FALSE, fig.alt = "Example of output when having 8 commits to push but then having to fetch and then rebase.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/fix-the-pull.png",error = FALSE)
```

After the `rebase` I was allowed to `push` and then everything is up to date.

### A bit more about git rebase

* Andy commits local changes, tries to `git push` but is told to first `git fetch` (to get Kim's changes from GitHub).
* Andy does `git fetch` and then `git rebase`.
* What `git rebase` does is basically rewind to the last common commit that both
  people had, and then add one person's commits and the others.
* Andy then does `git push` to push his commits to GitHub (from where Kim will fetch them when she's ready).
* Providing there are no conflicts, this will work fine.

Another option you hear about is to do a `git merge`, which basically creates a new commit that merges both people's work together.
In our teams we used to use `git merge` and now use `git rebase`; some people don't
like `git merge` because it adds extra commits.

For a more in-depth understanding [see here](https://reflectoring.io/git-rebase-merge/){target="_blank"} for one of the clearer explanations out there concerning rebase versus merge.

Note that the error in the above screenshot (when I could not `git push`) told
me that I might want to do `git pull`. This is basically

`git fetch`

`git merge`

in one command, but it seems preferable to do

`git fetch`

`git rebase`.

### Fixing a conflict

* A `r colorize("conflict")` happens when two people have edited the `r colorize("same line(s) of the same
  file")`.
* Conflicts happen relatively rarely and can be generally avoided by
  co-ordinating with collaborators so that you are working on different
  files. But, they will happen and you need to know how to resolve them.
* Git _forces_ you to explicitly decide whose changes to keep -- this is a `r colorize("good")`
  thing, since you want a human to make such a decision.

In the video we demonstrated a conflict.

The best approach I have found to fixing a conflict is the following:

* Trying `git rebase` will tell you there is a conflict.
* `git rebase --abort` -- do this to abort the rebase attempt.
* `git merge` -- this will tell you there is a conflict.
* Open the file(s) with the conflict and edit the text (see below).
* `git add <filename(s)>` -- you have to then add the files that had the conflict (I am not sure why this is necessary, I just do it).
* `git com "<message>"` -- in your commit message you can explain how you fixed
  the conflict. This is useful so that your collaborators know you have resolved
  a conflict (they can look at the commit to see if they are happy with it).

The merge message will tell you which files are conflicting. Open those files
one by one, and you will see the conflicted section bracketed like the
following:

```
<<<<<<< HEAD
Line(s) of text/code which are currently in your file.
 =======
Line(s) of text/code which are trying to merge in, but conflict.
>>>>>> origin/main
```

where `origin/main` refers to the version you have fetched from GitHub.
All you do is remove the line(s) of text that you do not want to keep (or edit
the line(s) to be something else entirely), and remove the bracketing lines
`<<<...` and `>>>...`, and the ` ======` line.

Save each conflicted file and then (as mentioned previously):

```
git add <filename(s)>
git com "Kept Kim's edits as more consistent with remaining text."
git p
```

### Exercise 3: collaborating on a single repository

If you have a colleague available, try what we just did:

* Person 1 creates a new repository on GitHub and clone to their computer.
* Give the Person 2 'push access' to the repository (on the repo page on GitHub: Settings -- Manage access -- Invite a collaborator)
* Person 2 clones to their computer
* Both create a simple text file (use different filenames), add some text and, as usual, `add`, `commit`, and `push`.
* `git fetch` and `git rebase` to get the other person's file.
* Continue editing either file, committing, and pushing.
* If you get the push error (shown earlier), refresh GitHub repository site to
  see recent commits (click on the X commits link, where X shows the total
  number of commits to the repository). You can easily spot the
  other person's recent commits. Click on one (the bold message) to see
  details.
* Purposefully create a conflict (both edit the same line of the same
  file). Resolve it as described earlier.
* In practice you won't commit so frequently when working, but this is good to get the hang of it.

### Collaborating summary

Congratulations, you now know the few basic commands and functionality needed to collaborate with Git and GitHub.
It takes a bit of practice, but it is very powerful.

`r colorize("95% of the time, this is all you are doing:")`

* Change some code.

```
git s
git d
git  com "My commit message"`
git p
```

(the `git s` and `git d` are useful to check you have changed only what you think you have changed).

If GitHub does not allow you to push then on GitHub check your colleague's latest commits
that you haven't yet seen, and if they look fine then:
```
git fetch
git rebase
```

(If you don't agree with your colleague's latest commits, then still rebase them
but then manually edit the files to be what you want. Though if you want to completely
cancel their commits see `git revert` in the Advanced section below).

If conflicts, then

```
git rebase --abort
git merge
```

fix the conflicts manually and then

```
git add <conflicted file(s)>
git com "Message to explain what you did"
git p
```

Change some code and repeat!

## Workflow tips when collaborating

Here are some tips that we've developed based on our own experiences.

Overall, remember that you still edit and save your files in the usual way on your
  local computer. If you don't do Git commits you will still have the `r colorize("latest versions
  of your files on your computer")`, as you would if you weren't using Git at all. So if
  you do get stuck with Git you can carry on working as normal (though you
  probably do want to try and fix it at some point).

When collaborating:

* If working closely with others, when you start each day (or after a break)
  then make sure you are up to date and have all their commits. Refresh the
  GitHub page for you repository, and `git fetch` (or just `git f`) and `git clone` if needed. (To
  be safe you can `git f` and `git s` to check).
* We find it helpful to co-ordinate our work (Slack is useful for this, or use
  GitHub Issues for complex discussion -- see below), so that if multiple people
  are working at the same time, you are at least not working on exactly the same
  parts, just to reduce conflicts.
* Commit fairly frequently and write helpful commit messages (so your colleagues
  get an idea of what you've done in each commit). Push less frequently, and
  _don't push code that doesn't work_ -- that will annoy your colleagues. And
  then they (and probably you) may both spend time fixing it.
* To see who last edited a particular piece of code, when viewing the file on
  GitHub click `r colorize("Blame")`, as mentioned earlier.

**GitHub Issues**

GitHub _Issues_ are very useful for discussing issues with your repo. For our
annual Pacific Hake assessment we have used them extensively over the years:

```{r, echo = FALSE, fig.alt = "Example screenshot of GitHub Issues, click on Issues in any repository in GitHub to see more.", width="100%", fig.align = "center"}
knitr::include_graphics("../module-1-git/images/hakeIssues21.png",error = FALSE)
```

The Issues tab lists our current 'Open' issues -- we have 20, of which five (the
most recently posted) are
shown here. We are currently in-between assessments (and not working on it), so
we have created Issues that we want to think about or deal with for next
year. This avoids forgetting about ideas or losing them in old emails.

Issues are intuitive to use. There is a bright green 'New Issues' button to
create new ones, you give a title and then write some details, people can reply,
you can assign people to look at them, and you can close them. In the above
screenshot you can see that we have closed 815 issues (this was over several years).

Useful tip: when doing a commit that refers to an Issue, if you refer to the
Issue number (with `#<number>`) in your commit message, then after pushing that commit the Issue on
GitHub will automatically mention and link to the commit:

`git com "Add more options to fancy_function(), #21."`

will mention the commit when you look at the issue. You can even automatically
close the issue by saying `closes #21` in your commit message:

`git com "Add more options to fancy_function(), closes #21."`

Issues are particularly useful to avoid cluttering up code with commented notes
or ideas that you may easily not come back to, or avoiding endless emails that
end up getting overlooked. You don't have to fix an Issue to close it, you can
decide not to pursue, but at least you have made a decision.

(We also use Slack a lot to communicate, but moreso for quick questions or
bouncing ideas around -- Issues are better for stuff that you want to come back
to at some point).

You may receive emails regarding Issues, but if you use GitHub a lot you will
see Notifications (the blue dot on the bell in the top-right corner when signed
in on GitHub) and that
will show you new Issues of repositories you are involved with, or if anyone has
updated an Issue.


**GitHub organizations**

If you will frequently collaborate with colleagues, you can create an
Organization on GitHub and invite collaborators to it (click on your GitHub
photo in the top-right corner, Settings, Organizations). Then they will
automatically have access to all repositories created under the
Organization. You can choose the security settings.

So, congratulations for getting this far -- we have covered the basics of Git
and GitHub to get you going. Occasionally you might get messed up, but it is
generally hard to actually lose any work. If you get stuck then see 'The power to go
back' part of the next section, that contains more advanced material. Good luck
and happy committing!
